\chapter{Spores}

\section{Introduction}

% The traditional view of software development as being focused on a program running
% on a single machine, interacting directly with the user, has become largely
% obsolete.

% Whether we consider a cluster of hundreds of commodity machines
% churning through a massive data-parallel job, or a smartphone interacting with
% a social network, all are ``distributed'' jobs, and all share the need to
% interact in typically asynchronous, reactive ways with other clients or
% services.

With the growing trend towards cloud computing, mobile applications, and big data,
distributed programming has entered the mainstream. Popular paradigms in software
engineering such as software as a service (SaaS), RESTful services, or the rise
of a multitude of systems for big data processing and interactive
analytics, evidence this trend.

Meanwhile, at the same time, functional programming has been undeniably
gaining traction in recent years, as is evidenced by the ongoing trend of
traditionally object-oriented or imperative languages being extended with
functional features, such as lambdas in \mbox{Java 8}~\cite{JavaLambdas},
C++11~\cite{CplusplusLambas}, and Visual Basic 9~\cite{Meijer}, the perceived
importance of functional programming in general empirical studies on software
developers~\cite{PLAdoption}, and the popularity of functional
programming massively online open courses (MOOCs)~\cite{ICSEMOOC}.

% , where the
% fundamental idea is to distribute data across nodes/threads and to perform the
% same task on the different pieces of this distributed data in parallel

One reason for the rise in popularity of functional programming languages and
features within object-oriented communities is the basic philosophy of
transforming immutable data by applying first-class functions, and the
observation that this functional style simplifies reasoning about data in
parallel, concurrent, and distributed code. A popular and well-understood
example of this style of programming for which many popular frameworks have
come to fruition is functional data-parallel programming.
Examples across functional and object-oriented paradigms include \mbox{Java
8}'s monadic-style optionally parallel collections~\cite{JavaLambdas}, Scala's
parallel~\cite{ScalaParColls} and concurrent dataflow~\cite{FlowPools}
collections, Data Parallel Haskell~\cite{DataParallelHaskell}, CnC~\cite{CnC}, Nova~\cite{Nova}, and Haskell's \verb|Par|
monad~\cite{HaskellPar} to name a few.

% Data-parallel programming has been established as a particularly successful
% and well-understood form of parallel programming across both programming
% paradigms (both functional and object-oriented proposals exist) and domains
% (high-performance computing, big data analytics, GPU programming, ...). A
% ``function-passing'' style of data-parallel programming, based on immutable
% data and first-class functions, enables more opportunities for optimization,
% safety, and verification opportunities~\cite{Nova}.

In the context of distributed programming, data-parallel frameworks like
MapReduce~\cite{MapReduce} and Spark~\cite{Spark} are designed
around functional patterns where closures are
transmitted across cluster nodes to large-scale persistent datasets. As a result of the ``big data'' revolution,
these frameworks have become very popular, in turn further highlighting the
need to be able to reliably and safely serialize and transmit closures over
the network.

% making the robust distribution of computations and % closures
% essential.

% Frameworks like Spark embody a pattern that we like to call ``Lambda The
% Ultimate Distributive'' where closures are shipped to the data such that (a)
% data to-be-processed as well as services local
% to a node are passed as arguments, and (b) data that needs to
% be shipped with the closure is captured and serialized.

% have to be pure or can't have access to mutable things

{\bf However, there's trouble in paradise.}~For both object-oriented and
functional languages, there still exist numerous hurdles at the language-level
for even these most basic functional building blocks, closures, to overcome in
order to be reliable and easy to reason about in a concurrent or distributed
setting.

In order to distribute closures, one must be able to serialize them -- a goal
that remains tricky to reliably achieve not only in object-oriented
languages but also in pure functional languages like Haskell:

\begin{lstlisting}
  sendFunc :: SendPort (Int -> Int) -> Int -> ProcessM ()
  sendFunc p x = sendChan p (\y -> x + y + 1)
\end{lstlisting}
\noindent
In this example, in function \verb|sendFunc| we are sending the lambda \verb|(\y -> x + y + 1)| on channel \verb|p|. The lambda captures variable \verb|x|, a parameter of \verb|sendFunc|. Serializing the lambda requires serializing also its captured variables. However, when looking up a serializer for the lambda, only the type of the lambda is taken into account; however, it doesn't tell us anything about the types of its captured variables, which makes it impossible in Haskell to look up serializers for them.

In object-oriented languages like Java or C\#, serialization is solved
differently -- the runtime environment is designed to be able to serialize any
object, reflectively. While this ``universal'' serialization might seem to
solve the problem of languages like Haskell that cannot rely on such a
mechanism, serializing closures nonetheless remains surprisingly error-prone.
For example, attempting to serialize a closure with transitive references to
objects that are not marked as serializable will crash at runtime, typically
with no compile-time checks whatsoever. The kicker is that it is remarkably
easy to accidentally and unknowingly create such a problematic transitive reference,
especially in an object-oriented language.

For example, consider the following use of a distributed collection in Scala
with higher-order functions \verb|map| and \verb|reduce| (using Spark):

\begin{lstlisting}
class MyCoolRddApp {
  val log = new Log(...)
  def shift(p: Int): Int = ...
  ...
  def work(rdd: RDD[Int]) {
    rdd.map(x => x + shift(x)).reduce(...)
  }
}
\end{lstlisting}
\noindent
In this example, the closure \verb|(x => x + shift(x))| is passed to the
\verb|map| method of the distributed collection \verb|rdd| which requires
serializing the closure (as, in Spark, parts of the data structure reside on
different machines). However, calling \verb|shift| inside the closure invokes
a method on the enclosing object \verb|this|. Thus, the closure is capturing,
and must therefore serialize, \verb|this|. If \verb|Log|, a field of
\verb|this|, is not serializable, this will fail at runtime.

In fact, closures suffer not only from the problems shown in these two
examples; there are numerous more hazards that manifest {\em across
programming paradigms}. To provide a glimpse, closure-related hazards
related to concurrency and distribution include:

% Unfortunately, besides the above mentioned problems, closures exhibit a variety of additional hazards, across programming paradigms.

\vspace{-2mm}
\begin{itemize}
\item accidental capture of non-serializable variables (including \verb|this|);
\item language-specific compilation schemes, creating implicit references to objects that are not serializable;
\item transitive references that inadvertently hold on to excessively large object graphs, creating memory leaks;
\item capturing references to mutable objects, leading to race conditions in a concurrent setting;
\item unknowingly accessing object members that are not constant such as methods, which in a distributed setting can have logically different meanings on different machines.
\end{itemize}

Given all of these issues, exposing functions in public APIs is a source of
headaches for authors of concurrent or distributed frameworks. Framework users
who stumble across any of these issues are put in a position where it's
unclear whether or not the encountered issue is a problem on the side of the
user or the framework, thus often adversely hitting the perceived reliability
of these frameworks and libraries.
% Furthermore, even internal
% function-based APIs pose serious software engineering challenges, since small
% changes to a codebase can affect the environment captured by a given closure,
% potentially rendering it suddenly not serializable or adding inadvertent
% race conditions, thus making refactoring error-prone, and debugging difficult.

We argue that solving these problems in a principled way could lead to more
confidence on behalf of library authors in exposing functions in APIs, thus
leading to a potentially wide array of new frameworks.
% , such as for concurrent and
% distributed functional reactive programming.

This paper takes a step towards more principled {\em function-passing style}
by introducing a type-based foundation for closures, called {\em spores}.
Spores are a closure-like abstraction and type system which is designed to
avoid typical hazards of closures. By including type information of captured
variables in the type of a spore, we enable the expression of type-based
constraints for captured variables, making spores safer to use in a concurrent
or distributed setting. We show that this approach can be made practical by
automatically synthesizing refinement types using macros, and by leveraging
local type inference. Using type-based constraints, spores allow expressing a
variety of ``safe'' closures.

To express safe closures with transitive properties such as guaranteed
serializability, or closures capturing only deeply immutable types, spores
support type constraints based on type classes which enforce transitive properties.
In addition, implicit macros in Scala enable integration with type systems that
enforce transitive properties using generics or annotated types. Spores also
support user-defined type constraints. Finally, we argue that by principle
of a type-based approach, spores can potentially benefit from optimization, further
safety via type system extensions, and verification opportunities.

The design of spores is guided by the following principles:

\begin{itemize}
\item {\bf Type-safety.} Spores should be able to express type-based
properties of captured variables in a statically safe way. Including type
information of captured variables in the type of a spore creates a number of
previously impossible opportunities; it facilitates the verification of
closure-heavy code; it opens up the possibility for IDEs to assist in safe
closure creation, advanced refactoring, and debugging support; it enables
compilers to implement safe transformations that can further simplify the use
of safe closures, and it makes it possible for spores to integrate with type
class-based frameworks like Scala/pickling~\cite{ScalaPickling}.

\item {\bf Extensibility.} Given types which include information about what  a
closure captures, libraries and frameworks should be able to restrict the
types that are captured by spores. Enforcing these {\em type constraints}
should not be limited to serializability, thread-safety, or other pre-defined
properties, however; spores should enable customizing the semantics of
variable capture based on user-defined types. It should be possible to use
existing type-based mechanisms to express a variety of user-defined properties
of captured types.

\item {\bf Ease of Use.} Spores should be lightweight
to use, and be able to integrate seamlessly with existing practice. It should
be possible to capitalize on the benefits of precise types while at the same
time ensuring that working with spores is never too verbose, thanks
to the help of automatic type synthesis and inference. At the same time,
frameworks like Spark, for which the need for controlled capture is central,
should be able to use spores, meanwhile requiring only minimal changes in
application code.

\item {\bf Practicality.} Spores should be practical to use in general, as
well as be practical for inclusion in the full-featured Scala language. They
should be practical in a variety of real-world scenarios (for use with Spark,
Akka, parallel collections, and other closure-heavy code). At the same time,
to enable a robust integration with the host language, existing type system
features should be reused instead of extended.

\item {\bf Reliability for API Designers.} Spores should enable library
authors to confidently release libraries that expose functions in user-facing
APIs without concern of runtime exceptions or other dubious errors falling on
their users.

\end{itemize}
