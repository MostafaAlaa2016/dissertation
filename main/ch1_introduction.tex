\chapter{Introduction}

Distributed programming is fundamentally different than . Without even realizing
it,. It requires a

Programming for distributed systems is hard. All it takes is a quick glance at
the literature, both academic and industrial, to see that distributed systems
builders have long since grappled with fundamental concerns like consistency,
availability, and latency across systems designs.

The performance characteristics of the underlying programming language and
runtime, however, should not weigh in

Major goal of this thesis is to retroactively add support for distributed
computation to an existing and widespread language with functional features.

Many efforts have been undertaken to design from scratch a new foundation for
distribution. Cite Leo.


The closest the literature gets at present to the intersection of programming
languages and falls in the direction of Datalog and the idea that ensuring that
properties like monotonicity

Nitty gritty concerns like serialization or ensuring that are left largely
unconsidered. As an industry, we simply deal with the fact that Java 8 now has
closures, but that closures have no added support to ensure that they are
serializable, instead suggesting ``the serialization of lambda expressions is
strongly discouraged.''\footnote{From the official Java documentation on lambda
expressions, available at
\url{https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html\#serialization}}

\section{Distributing Computation}



Erlang, Elixir. But no types. Go for fault tolerance? Bloom language.

Sequoia. (?)

Oz dataflow.

Up to 50\% of the time for some Spark jobs spent in
serialization~\cite{OusterhoutSerialization}.

Datalog, Datomic, Cascalog. Query evaluation with Datalog is based on first
order logic, and is thus sound and complete. However, Datalog is not Turing
complete, and is thus used as a domain-specific language that can take advantage
of efficient algorithms developed for query resolution. Datalog is a lightweight
deductive database system where queries and database updates are expressed in
the logic language. The use of Datalog syntax and an implementation based on
tabling intermediate results ensures that all queries terminate.

Datalog is a nonprocedural query language based on the logic-programming
language Prolog.  A user describes the information desired without giving a
specific procedure for obtaining that information. Datalog simplifies writing

Much effort invested in a formal foundation for concurrent and distributed
programming -- e.g., process calculi. Pi calculus. Join calculus.

Join-patterns provides a way to write concurrent, parallel and distributed
computer programs by message passing. Compared to the use of threads and locks,
this is a high level programming model using communication constructs model to
abstract the complexity of concurrent environment and to allow scalability. Its
focus is on the execution of a chord between messages atomically consumed from a
group of channels.

Recent research has explored using Datalog-based languages to express a
distributed system as a set of logical invariants.

Languages foundations like Dedalus~\cite{Dedalus} focus on providing a minimal set of
primitives for programming and reasoning about distributed systems. Dedalus
reduces to a subset of Datalog with negation, aggregate functions,
successor and choice, and admits an explicit representation of time into the
logic language in order to provide a declarative foundation for the two
signature features of distributed systems: mutable state, and asynchronous
processing and communication.

NoSQL = Datalog! Function-passing is a stateless model of this idea. All about
using logic to reduce coordination.

These languages and efforts differ from the effort presented in this thesis in
that logic-based . They are trying to figure out ways to jointly do
optimizations and to ensure a number of other properties important to
distributed systems with state remain in tact. When a theoretical result is
arrived at in this work of databases and data-centric programming systems, the
sole effort to date concerned with integrating these advancements into the
programming language has focused on providing a restricted logic programming
language to attempt to ensure correctness and ease of reasoning. These are not
the goals of this thesis. Instead, we focus less on providing langauge featuers designed to shield users from complications that arise when having to worry about consistency (after all,


The rationale of some in purporting a language to be more adept at distributed
programming has focused on languages which remove limitations and which enable
more features to be distributed.

That is not the central tenet of this thesis. Rather, this thesis argues that
while indeed more language features ought to be more reliably distributed (e.g.,
function closures) it might not be preferable that all features be given
unrestricted support for distribution. That is, in this thesis,

This thesis follows the advice given in 's Note On Distributed computing, where
important advice is to avoid abstracting over network communication. Other
models tout such abstraction to be a feature, or to from a programming language
perspective provide for a more powerful or otherwise desirable . Like Note, we
argue that this is not the case. Designers of distributed systems must have a
handle on and be aware of all situations that could cause network communication.

The distributed model of computation behind Oz~\cite{DistributedOz} abstracts
over communication boundaries. Network transparency
~\cite{ConceptsTechniquesModelsProgramming}

In this thesis, rather than abstracting over network communication, we provide
firmer, more desirable primitives to initiate your own network communication.


\section{Thesis}

The goal of this dissertation is to improve the above state of affairs
Part of this thesis aims to imagine what a more functional model for distributed programming looks like.

This dissertation addresses the following questions:

\begin{itemize}

	\item How can existing programming language features be improved in order to
	better support concerns like performance and latency across a general slice of
	distributed systems?

	\item Which important features and aspects of existing programming languages
	are left unsupported by the language in the face of distribution? Is it
	possible to support such features?

	\item How can core ideas behind the development of functional programming be
	applied to the distributed scenario? What other models for functional
	programming in a distributed environment are there?

	\item What are good abstractions for reasoning about concerns like network I/O
	and failure at the level of the compiler and programming language?

\end{itemize}

\section{Contributions}

This dissertation describes a number of extensions and libraries in and for
Scala which aim to provide a more reliable foundation for building distributed
systems atop of. Importantly, a goal throughout this dissertation was not only
to add better support the basics of distributed programming, but to do it {\em
without extending the Scala compiler}. As a mainstream language with hundreds of
thousands of users.

\begin{itemize}

	\item Abstractions and data structures for asynchronous programming.

	\item

\end{itemize}

\section{Structure}

The rest of this dissertation is organized as follows.

\begin{itemize}

	\item Chapter 2 describes {\em futures} and {FlowPools}, funtionally-inspired
	and fully asynchronous and non-blocking single-assignment variables (futures)
	and pools (FlowPools) useful for reducing coordination in distributed systems.
	The chapter sketches a proof of linearizability, lock-freedom, and determinism
	of FlowPools. The full proof of lock-freedom can be found in
	Appendix~\ref{appdx:flowpools}, and the full proofs of linearizability and
	determinism can be found in the companion technical report~\cite{Prokopec12}.

	\item Chapter 3 introduces {\em object oriented picklers} and {\em
	scala/pickling}, a new distribution-focused approach to serialization that
	generates serialization code statically, allowing for more type safety. The
	chapter includes a formalization of object oriented picklers as well as a
	description of the generation algorithm used for automatically generating
	picklers for arbitrary types. A performance evaluation is also included which
	examines the performance of the serialization framework across different sorts
	of serilaization workloads, and which compares scala/pickling against other
	state-of-the art serialization systems like Java and Kryo, and reports
	significant speedups.

	\item Chapter 4 covers a new technique for extensible and static datatype
	generic programming. In this chapter, the generation technique used for
	generating pickling code is generalized to be able to generate arbitrary type
	class instances, at compile time.

	\item Chapter 5 introduces {\em spores}, a new abstraction and type system
	designed to enable function closures to be serializable by design. The type
	system presented here also generalizes its added static checking capabilities
	to arbitrary user-defined {\em properties}, \eg immutability.

	\item Chapter 6 describes a new programming model for functional distributed
	programming called {\em function-passing} which aims to simplify the
	implementation and reasoning of fault tolerance mechanisms. Because the model
	requires user programs to themselves be stateless, issues like consistency are
	moot. This programming model can be thought of as a generalization of the Spark
	or MapReduce programming model.

	\item Chapter 7 concludes and discusses possible directions for future work.

\end{itemize}

\section{Previously Published Material}

This dissertation draws heavily on earlier work described in the following
papers, written jointly with several collaborators (in the order of appearance
in this disseratation):

\begin{itemize}

	\item Prokopec, Miller, Schlatter, Haller, and Odersky (2012).
	\href{http://infoscience.epfl.ch/record/180265}{FlowPools: A lock-free
	deterministic concurrent dataflow abstraction}. In proceedings of Languages and
	Compilers for Parallel Computing (LCPC).

	\item Miller, Haller, Burmako, and Odersky (2013).
	\href{http://infoscience.epfl.ch/record/188383}{Instant Pickles: Generating
	object-oriented pickler combinators for fast and extensible serialization}. In proceedings of the ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA).

	\item Miller, Haller, and Odersky (2014).
	\href{http://infoscience.epfl.ch/record/191239}{Spores: A type-based
	foundation for closures in the age of concurrency and distribution}. In
	proceedings of the European Conference on Object-Oriented Programming (ECOOP).

	\item Haller and Miller (2015).
	\href{https://infoscience.epfl.ch/record/205039}{Distributed Programming
	via Safe Closure Passing}. In proceedings of Programming Language Approaches to
	Concurrency and Communication-centric Software (PLACES).

\end{itemize}

Works that this dissertation draws upon that have been submitted but at the time
of the writing remain in technical report form include:

\begin{itemize}

	\item Miller, Haller, and C. D. S. Oliveira (2015). \href{http://infoscience.epfl.ch/record/199389}{Self-Assembly: Lightweight language extension and datatype generic programming, all-in-one!}. EPFL technical report \#EPFL-CONF-199389.

	\item Miller and Haller (2015).
	\href{http://infoscience.epfl.ch/record/205822}{Function Passing: A model for
	typed, distributed functional programming}. EPFL technical report
	\#EPFL-CONF-205822.

\end{itemize}
