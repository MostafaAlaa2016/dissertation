%\begingroup
%\let\cleardoublepage\clearpage


% English abstract
\cleardoublepage
\chapter*{Abstract}
\markboth{Abstract}{Abstract}
\addcontentsline{toc}{chapter}{Abstract (English/Deutsch)} % adds an entry to the table of contents


Software development has taken a fundamental turn. Software today has gone from
simple, closed programs running on a single machine, to massively open programs,
patching together user experiences byway of responses received via hundreds of
network requests spanning multiple machines. At the same time, as data continues
to stockpile, systems for big data analytics are on the rise. Yet despite this
trend towards distributing computation, issues at the level of the language and
runtime abound. Serialization is still a costly runtime affair, crashing running
systems and confounding developers. Function closures are being added to APIs
for big data processing for use by end-users without reliably being able to
transmit them over the network. And much of the frameworks developed for
handling multiple concurrent requests byway of asynchronous programming
facilities rely on blocking threads, causing serious scalability issues.

\vspace{0.2cm}

This thesis describes a number of extensions and libraries for the Scala
programming language that aim to address these issues and to provide a more
reliable foundation on which to build distributed systems.

\vspace{0.2cm}

This thesis presents a new approach to serialization called {\em pickling} based
on the idea of generating and composing functional pickler combinators
statically. The approach shifts the burden of serialization to compile time as
much as possible, enabling users to catch serialization errors at compile time
rather than at runtime. Further, by virtue of serialization code being generated
at compile time, our framework is shown to be significantly more performant than
other state-of-the-art serialization frameworks. We also generalize our
technique for generating serialization code to  generic functions other than pickling.

\vspace{0.2cm}

Second, in light of the trend of distributed data-parallel frameworks
being designed around functional patterns where closures are transmitted across
cluster nodes to large-scale persistent datasets, this thesis introduces a new
closure-like abstraction and type system, called {\em spores}, that can
guarantee closures to be serializable, thread-safe, or even have custom
user-defined properties. Crucially, our system is based on the principle of
encoding type information corresponding to captured variables in the type of a
spore. We prove our type system sound, implement our approach for Scala,
evaluate its practicality through a small empirical study, and show the power of
these guarantees through a case analysis of real-world distributed and
concurrent frameworks that this safe foundation for closures facilitates.

\vspace{0.2cm}

Finally, we bring together the above building blocks, pickling and spores, to
form the basis of a new programming model called {\em function-passing}.
Function-passing is based on the idea of a distributed persistent data structure
which stores in its nodes transformations to data rather than the distributed
data itself, simplifying fault recovery by design. Lazy evaluation is also
central to our model; by incorporating laziness into our design only at the
point of initiating network communication, our model remains easy to reason
about while remaining efficient in time and memory. We formalize our programming
model in the form of a small-step operational semantics which includes a precise
specification of the semantics of functional fault recovery, and we provide an
open-source implementation of our model in and for Scala.




% A goal of this dissertation is to revisit the fundamental concepts of modern
% languages, objects and functions, and to make them safer and more efficient to
% use in a distributed environment. We focus on three important and orthogonal
% building blocks for distributed programming.



% But programming languages haven't kept up.

% We present a number of extensions to the Scala programming language which aim to
% provide a more reliable foundation on which to build distributed systems.

% programs and systems which
% are in some sense distributed.



\vskip0.5cm
Key words: distributed programming, functional programming, closure, serialization, programming model, concurrency, asynchronous programming, dataflow.
%put your text here


% German abstract
\begin{otherlanguage}{german}
\cleardoublepage
\chapter*{Zusammenfassung}
\markboth{Zusammenfassung}{Zusammenfassung}

Die Software-Entwicklung hat eine grundlegende Wendung durchlaufen. Software hat
sich heutzutage von einfachen geschlossenen Programmen, die auf einem einzigen
Rechner laufen, hin zu „massive open programs“ gewandelt, die Nutzeranfragen
zusammenführen, die als Antworten von hunderten von Netzwerkanfragen an eine
Vielzahl an Diensten eingegangen sind. Zeitgleich dazu werden Daten weiterhin
angesammelt und Systeme für Big Data Analytics sind auf dem Vormarsch. Trotz des
Trends zum verteilten Computing, sind Fragen zu Programmiersprachen und
Laufzeitsystemen im Überfluss vorhanden. Serialisierung ist hinsichtlich der
Laufzeit nach wie vor eine kostspielige Angelegenheit, die laufende Systeme zum
Abstürzen bringt und Entwickler verwirrt. Funktions-Closures werden zu APIs
hinzugefügt, um durch Anwendungsentwickler zum Bearbeiten von Datensätzen
massiver Grösse genutzt werden zu können, jedoch ohne sicherzustellen, dass
diese über das Netzwerk gesendet werden können. Und ein Grossteil der
Frameworks, die zur Verarbeitung multipler, gleichzeitiger Anfragen durch
asynchrone Programmierabstraktionen entwickelt wurden, basiert auf dem
Blockieren von Threads, was schwerwiegende Skalierungsprobleme verursacht.

\vspace{0.2cm}

Die vorliegende Dissertation beschreibt eine Reihe von Erweiterungen und
Bibliotheken für die Programmiersprache Scala, um die genannten Probleme
anzugehen und eine zuverlässigere Grundlage für die Konstruktion verteilter
Systeme zu entwickeln.

\vspace{0.2cm}

Die Arbeit stellt einen neuen Ansatz zur Serialisierung, {\em Pickling}, vor,
welcher auf der Idee der Generierung und Komposition statischer
Pickling-Funktionen beruht. Dieser Ansatz verlagert den Aspekt der
Serialisierung so stark wie möglich auf die Übersetzungszeit, um Anwendern zu
ermöglichen, Serialisierungsfehler zur Übersetzungszeit zu erkennen statt zur
Laufzeit. Des Weiteren ist unser Framework durch den Serialisierungscode, der
beim Kompilieren erzeugt wird, deutlich performanter als andere existierende
Serialisierungs-Frameworks. Zudem verallgemeinern wir unseren Ansatz zur
Generierung weiterer Datentyp-generischer Funktionen neben der Serialisierung.

\vspace{0.2cm}

In Anbetracht der Tendenz verteilter daten-paralleler Frameworks, die für
funktionelle Muster entworfen wurden, bei denen Closures über Cluster-Knoten zu
großen persistenten Datensätzen übertragen werden, stellt diese Arbeit eine neue
Closure-artige Abstraktion und Typsystem, {\em Spores}, vor, dass garantieren
kann, dass Closures serialisierbar sind, Thread-sicher sind, und sogar
benutzerdefinierte Eigenschaften haben. Entscheidend ist, dass unser System auf
dem Prinzip basiert, im Typ eines Spores Typinformation zu kodieren, welche den
gefangenen Variablen entspricht. Wir beweisen die Korrektheit unseres
Typsystems, implementieren unseren Ansatz in Scala, evaluieren dessen
Praktikabilität mithilfe einer kleinen empirischen Studie, und zeigen die
Mächtigkeit dieser Garantien mithilfe einer Fallstudie realistischer verteilter
und nebenläufiger Frameworks, die durch diese sichere Grundlage für Closures
unterstützt werden.

\vspace{0.2cm}

Schließlich bringen wir die obengenannten Bausteine, Pickling und Spores,
zusammen, um die Basis eines neuen Programmiermodells, genannt  {\em
Function-Passing}, zu bilden. Function-Passing basiert auf der Idee einer
verteilten persistenten Datenstruktur, die in ihren Knoten
Daten-Transformationen anstelle der verteilten Daten selbst enthält, was die
Fehlerbeseitigung per Konstruktion vereinfacht. Lazy Evaluation ist auch von
zentraler Bedeutung für unser Modell; da Lazy Evaluation in unserem Design nur
an der Stelle der Initiierung von Netzwerk-Kommunikation Bedeutung hat, bleibt
die logische Grundlage unseres Modells leicht verständlich, während es
hinsichtlich Zeit und Speicherverbrauch effizient bleibt. Wir formalisieren
unser Programmiermodell in Form einer strukturierten operationellen Semantik,
die eine präzise Spezifikation der Semantik funktionaler Fehlerbeseitigung
umfasst, und wir stellen eine Open-Source-Implementierung unseres Modells in und
für Scala bereit.




\vskip0.5cm

Stichwörter: Verteilte Programmierung, Funktionale Programmierung, Closure,
Serialisierung, Programmiermodell, Nebenläufigkeit, Asynchrone Programmierung,
Datenfluss
%put your text here
\end{otherlanguage}

% % French abstract
% \begin{otherlanguage}{french}
% \cleardoublepage
% \chapter*{Résumé}
% %\markboth{Résumé}{Résumé}
% % put your text here
% \lipsum[1-2]
% \vskip0.5cm
% Mots clefs:
% %put your text here
% \end{otherlanguage}


%\endgroup
%\vfill
